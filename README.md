# light

Sane defaults for high performance, reliable hardware prototyping so you can iterate at the speed of light.

Uses [dora](https://github.com/raghavauppuluri13/dora) as shared memory IPC backend. Use C for high performance stuff, and python for human interface tooling. Can be used as a lightweight drop-in replacement for ROS.

## Compatability
- Use pyenv for python version management and venv creation

##### Tested
- python = 3.10.10
- linux = ubuntu 20.04

##### Untested, but should work
- macos = (should work, but may need to adjust SConstruct to build on macos)

##### Unsupported
- Windows

## Preliminaries

##### Using C

All `src` files that end in `_node.c` have their own main file, and are compiled into `build`. For build simplicity, all files are kept in `src`.

##### Using Python

All `scripts` files can be runnable, python dora nodes should end in `_node.py`. Write utility code and python infra modules in the `light` python package.

Refer to examples in `scripts/examples`

##### Launching/Running code

Using dora's dataflow syntax, you can define all your node and their inputs/outputs in a single yaml file, see `launch/examples/quickstart.yml`

##### Config Management

Each hardware configuration has a `config/(CONFIG_NAME).toml` file to fully describe all static parameters shared between python and c.
These are constants and are exported via `CONFIG=<CONFIG_NAME> make setup` or `CONFIG=<CONFIG_NAME> make` to be easily available via 
python: `import light.utils.constants as CFG` and c/c++: `#include "constants.h"`. 

These are autogenerated by `light.parsers.parse_config`.

##### IPC and Message Passing

> "Keep it simple. No abstractions. It's just float arrays and operations on float arrays." - Andrej Karpathy on llm.c

Found that it is sufficient to just send fixed size arrays of ints and floats between C and python and repackage them on either side.

Complex serialization isn't worth overoptimizing for simple applications when using shared memory IPC, but for more complex needs, use capnproto (TODO).

Define messages for your config in `messages/(CONFIG_NAME).toml` make sure you use a single type across each message. Refer to `messages/quickstart.toml` for example messages. 
Read/send functionality is autogenerated in python and c by `light.parsers.parse_messages`.

python: `import light.utils.messages as MSG`. See `light.utils.message_utils` for an example of how to use in python.
c/c++: `#include "messages.h"`. See `src/quickstart_node.c` for usage in c.

## Quick start
1. clone repo recursively: `git clone --recursive https://github.com/raghavauppuluri13/light`
1. install repo: `make install`
2. run `make`, default config is `config/quickstart.yml`, use `CONFIG=quickstart make` to compile with the quickstart config
3. run `dora up`
4. run `dora start launch/examples/quickstart.yml`

## Customize this repo

After cloning, replace all instances of `light` with `your_project` with `rename.sh light <PROJECT_NAME>`

## Roadmap
- [ ] Add first class support to zerorpc with nameserver 
- [ ] Extend other messages/configs to allow easier portability
- [ ] Add robotics starter examples (CAN, ethercat, 
- [ ] Add capnproto-like serialization
- [ ] Remove dora dependency, switch to custom c only implementation of [msgq](https://github.com/commaai/msgq/tree/master)
